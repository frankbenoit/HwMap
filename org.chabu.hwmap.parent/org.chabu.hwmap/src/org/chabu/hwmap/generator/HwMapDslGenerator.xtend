/*
 * generated by Xtext 2.19.0
 */
package org.chabu.hwmap.generator

import java.nio.file.Paths
import java.util.ArrayList
import java.util.List
import org.chabu.hwmap.hwMapDsl.MemoryMap
import org.chabu.hwmap.hwMapDsl.Output
import org.apache.log4j.Logger
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.diagnostics.ExceptionDiagnostic
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.chabu.hwmap.hwMapDsl.RegisterBits
import org.chabu.hwmap.hwMapDsl.Register
import org.chabu.hwmap.hwMapDsl.Block
import org.chabu.hwmap.hwMapDsl.Instantiation
import org.chabu.hwmap.generator.HwMapDslGenerator.Struct
import org.chabu.hwmap.hwMapDsl.Component

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class HwMapDslGenerator extends AbstractGenerator {
	
	static val log = Logger::getLogger(HwMapDslGenerator)

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for( mm : resource.allContents.filter(MemoryMap).toIterable ){
			try {
				
				prepareData(mm)
				for( output : mm.outputs ){
					switch output.mode {
						case 'C':
							generateC( mm, fsa, output )
						case 'VHDL':
							generateVhdl( mm, fsa, output )
						default:
							throw new RuntimeException('''Unknown output mode «output.mode».''')
					}
				}
					
			}
			catch( RuntimeException e ){
				mm.eResource.errors.add( new ExceptionDiagnostic( e ) )
				log.error("Generator Exception", e);
			}
		}
	}
	
	private static class Constant {
		String name
		String typeVhdl
		String value
		String valueVhdl
	}
	
	private static class StructField {
		String type
		String name
		String arrayDim
	}
	
	private static class Struct {
		int size
		String name
		List<StructField> fields = new ArrayList
	}
	
	private static class VhdlComp {
		String name
		int    addrIdxHi;
		val blocks = new ArrayList<VhdlBlock>();
		val insts  = new ArrayList<VhdlInstSelect>();
	}
	
	private static class VhdlBlock {
		String name
		int    addrIdxHi;
		int    addrIdxLo;
		val registers = new ArrayList<VhdlRegister>();
	}
	
	private static class VhdlInstSelect {
		String name
		int    addrIdxHi;
		int    addrIdxLo;
		String addrBits;
	}
	
	private static class VhdlRegister {
		String name
		String addrBits;
	}
	
	val vhdlComps = new ArrayList<VhdlComp>();
	var vhdlComp = new VhdlComp;
	
	val constants = new ArrayList<Constant>();
	val structs = new ArrayList<Struct>();
	val align = 4
	var nextOffset = 0
	var dummyIndex = 0
		
	def private prepareData(MemoryMap mm) {
		
		constants.clear()
		structs.clear()
		
		for( Output out : mm.outputs ){
			handleOutput(out)
		}
			
		for( comp : mm.components ){
			val compStruct = new Struct
			compStruct.name = comp.compName
			
			vhdlComp = new VhdlComp()
			vhdlComps.add(vhdlComp)
			vhdlComp.name = comp.compName
						
			if( comp.size % align != 0 ){
				throw new RuntimeException('''Component «comp.compName» has non-aligned size of «comp.size».''')
			}
			if( Integer::bitCount(comp.size) != 1 ){
				throw new RuntimeException('''Component «comp.compName» has non-power-2 size''')
				
			}
			vhdlComp.addrIdxHi = Integer::numberOfTrailingZeros(comp.size)-1
			
			
			for( block : comp.blocks ){
				handleBlock( block, comp )
			}
			

			dummyIndex = 0
			nextOffset = 0
			for( inst : comp.insts ){
				handleInstance( inst, compStruct, comp )
			}
			
			structs.add(compStruct)
		}
	}
	
	def handleOutput(Output output) {
		val path = Paths.get(output.path)
		if( path.root !== null ){
			throw new RuntimeException('''Output path must be a relative path. Not «path»''')
		}
	}
	
	def private handleBlock(Block block, Component comp) {
		dummyIndex = 0
		nextOffset = 0
		val struct = new Struct
		struct.name = '''«comp.compName»_«block.name»'''
		struct.size = block.size
		if( block.size % align != 0 ){
			throw new RuntimeException('''Block «block.name» has non-aligned size of «block.size».''')
		}
		if( Integer::bitCount(block.size) != 1 ){
			throw new RuntimeException('''Block «block.name» has non-power-2 size''')
		}
		val vhdlBlock = new VhdlBlock()
		vhdlBlock.name = block.name
		vhdlBlock.addrIdxHi = Integer::numberOfTrailingZeros(block.size)-1
		vhdlBlock.addrIdxLo = 2
		vhdlComp.blocks.add(vhdlBlock)
		
		for( reg : block.regs ){
			handleRegister( reg, struct.name, block, struct, vhdlBlock )
		}
		val fillSize = (struct.size - nextOffset) / align;
		if( fillSize > 0 ) {
			fillDummy( struct, fillSize, dummyIndex++ )
		}
		
		structs.add(struct)

	}
	
	def private handleInstance(Instantiation inst, Struct compStruct, Component comp ) {
		val field = new StructField
		field.name = '''«inst.name»'''
		field.type = '''struct «compStruct.name»_«inst.type»'''
	
		if( inst.addr % align != 0 ){
			throw new RuntimeException('''Instance «field.name» has non-aligned offset of «inst.addr».''')
		}

		val fillSize = (inst.addr - nextOffset) / align;
		if( fillSize < 0 ){
			throw new RuntimeException('''Instance «field.name» has no increasing offset. Minimum expected offset is «String::format("0x%X", nextOffset)»''')
		}
		if( fillSize > 0 ){
			fillDummy( compStruct, fillSize, dummyIndex++ )
			nextOffset = inst.addr
		}
		compStruct.fields.add(field)
		val block = comp.blocks.findFirst[b| b.name == inst.type];
		if( block === null ){
			throw new RuntimeException('''Block instance type «compStruct.name» «inst.type» cannot be resolved.''')
		}
		if( inst.addr % block.size != 0 ){
			throw new RuntimeException('''Block instance «inst.name» at address «inst.addr» is not multiple of block size «block.size».''')
		}
		
		val vhdlInstSelect = new VhdlInstSelect()
		vhdlInstSelect.addrIdxHi = vhdlComp.addrIdxHi
		vhdlInstSelect.addrIdxLo =  Integer::numberOfTrailingZeros(block.size)
		vhdlInstSelect.addrBits = bitsFromInt( inst.addr, vhdlInstSelect.addrIdxHi, vhdlInstSelect.addrIdxLo )
		vhdlInstSelect.name = inst.name
		vhdlComp.insts.add(vhdlInstSelect)
		
		nextOffset += block.size
	}
	
	def private String bitsFromInt( int value, int idxHi, int idxLo ){
		val sb = new StringBuilder
		for( var i = idxHi; i >= idxLo; i-- ) {
			val bitMask = (1<<i) as int
			val bitVal = bitMask.bitwiseAnd(value) != 0
			sb.append( bitVal ? '1' : '0')
		}
		return sb.toString
	}
	def private handleRegister(Register reg, String structName, Block block, Struct struct, VhdlBlock vhdlBlock ) {
		val field = new StructField
		val fieldFqn = '''«structName»_«reg.name»'''
		field.name = reg.name
		field.type = 'uint32'
		
		val vhdlRegister = new VhdlRegister()
		vhdlRegister.addrBits = bitsFromInt( reg.addr, vhdlBlock.addrIdxHi, vhdlBlock.addrIdxLo );
		vhdlRegister.name = reg.name
		vhdlBlock.registers.add(vhdlRegister)
			
		
		if( reg.addr % align != 0 ){
			throw new RuntimeException('''Register «reg.name» has offset of «reg.addr». Must be multiple of «align»''')
		}
		if( reg.addr < nextOffset ){
			throw new RuntimeException('''Registers «reg.name» must have increasing offset to previous register''')
		}
		if( reg.addr > nextOffset ){
			val arraySize = (reg.addr - nextOffset) / align;
			fillDummy( struct, arraySize, dummyIndex++ )
		}
		if( reg.addr + align > block.size ){
			throw new RuntimeException('''Registers «reg.name» does not fit into block «block.name» with size «String::format("0x%X", block.size )»''')
		}
		nextOffset = reg.addr + align
		for( const : reg.consts ){
			addConstHex( '''«fieldFqn»_CONST_«const.name»''', const.value, 32 )
		}
		for( bits : reg.bits ){
			handleBits( bits, reg.name, fieldFqn )
		}
		struct.fields.add(field)
	}
	
	def private handleBits(RegisterBits bits, String regName, String fieldFqn ) {
		val bitsName = '''«fieldFqn»_«bits.name»'''
		val highBit = bits.range.left
		val lowBit = ( bits.range.right !== null ) ? bits.range.right : bits.range.left
		val width = highBit - lowBit +1
		val mask = (( 1 << width ) - 1) << lowBit
		
		if( lowBit < 0 ){
			throw new RuntimeException('''Registers «regName» bits «bits.name» low bit is negative''')
		}
		if( highBit > 31 ){
			throw new RuntimeException('''Registers «regName» bits «bits.name» high bit is >31''')
		}
		if( highBit < lowBit ){
			throw new RuntimeException('''Registers «regName» bits «bits.name» low bit > high bit''')
		}
		
		addConst( '''«bitsName»_BITPOS''', lowBit )
		addConst( '''«bitsName»_WIDTH''', width )
		addConstHex( '''«bitsName»_MASK''', mask, width )
		
		for( const : bits.consts ){
			addConstHex( '''«bitsName»_CONST_«const.name»''', const.value, width )
		}
	}
	
	def private void fillDummy( Struct struct, int wordSize, int dummyIndex ){
		val dummyField = new StructField
		dummyField.name = '''__dummy_«dummyIndex»'''
		dummyField.type = 'uint32'
		if( wordSize > 1 ){
			dummyField.arrayDim = String.format("[0x%X]", wordSize)
		}
		struct.fields.add(dummyField)
	}

	def private void addConst( String name, int value ){
		val c = new Constant()
		c.name = name
		c.typeVhdl = '''integer'''
		c.value = Integer.toString(value)
		c.valueVhdl = Integer.toString(value)
		constants.add(c)
	}
	
	def private void addConstHex( String name, int value, int bitWidth ){
		val c = new Constant()
		c.name = name
		c.typeVhdl = '''std_logic_vector( «bitWidth-1» downto 0 )'''
		c.value = String.format("0x%X", value)
		c.valueVhdl = String.format("CONV_STD_LOGIC_VECTOR( 16#%X#, %d )", value, bitWidth )
		constants.add(c)
	}
	
	def private void generateC( MemoryMap mm, IFileSystemAccess2 fsa, Output output ){
		
		val id = Paths.get(output.path).fileName.toString
			.toUpperCase
			.replaceAll("[.-]", "_")
		
		
		log.info( String::format("Write C header: %s", output.path ))
		fsa.generateFile(output.path, '''
		// generated by HwMap : https://github.com/frankbenoit/HwMap
		#ifndef «id»
		#define «id»
		
		«FOR c:constants»
		#define «c.name» «c.value»
		«ENDFOR»
		«FOR s:structs»
		
		struct «s.name» {
		    «FOR f:s.fields»
		    «f.type» «f.name»«f.arrayDim»;
		    «ENDFOR»
		}
		«ENDFOR»
		
		#endif
		''');
	}
	def private void generateVhdl( MemoryMap mm, IFileSystemAccess2 fsa, Output output ){
		
		val id = Paths.get(output.path).fileName.toString
			.toLowerCase
			.replaceAll("\\.vhd", "")
			.replaceAll("[.-]", "_")

		log.info( String::format("Write VHDL package: %s", output.path ))
		fsa.generateFile(output.path, '''
		-- generated by HwMap : https://github.com/frankbenoit/HwMap
		library IEEE;
		use IEEE.STD_LOGIC_1164.ALL;
		
		package «id»_pck is
		
		  «FOR c:constants»
		  constant «c.name» : «c.typeVhdl» := «c.valueVhdl»;
		  «ENDFOR»
		  «FOR c:vhdlComps»
		  «FOR b:c.blocks»
		  type Block_«c.name»_«b.name»_Selection is record
		    UnmappedSelection : std_logic;
		    «FOR r:b.registers»
		 «"    "»Selected_«r.name» : std_logic;
		    «ENDFOR»
		  end record;

		  «ENDFOR»
		  type Comp_«c.name»_Selection is record
		    «FOR b:c.blocks»
		    Block_«b.name» : Block_«c.name»_«b.name»_Selection;
		    «ENDFOR»
		    UnmappedSelection : std_logic;
		    «FOR i:c.insts»
		 «"    "»Selected_«i.name» : std_logic;
		    «ENDFOR»
		  end record;

		  «ENDFOR»
		end package «id»_pck;
		
		«FOR c:vhdlComps»
		library IEEE;
		use IEEE.STD_LOGIC_1164.ALL;

		entity «id»_Decoder_«c.name» is
		  Port (
		    addr  : in std_logic_vector( «c.addrIdxHi» downto 0 );
		    cycle : in std_logic;
		    selection : out work.«id»_pck.Comp_«c.name»_Selection );
		end out_Decoder_CapSim;
		
		architecture Behavioral of «id»_Decoder_«c.name» is
		  signal res : work.«id»_pck.Comp_«c.name»_Selection;
		begin
		  selection <= res;
		  res.UnmappedSelection <= '1' when
		    «FOR i:c.insts»
		    res.Selected_«i.name» = '0' and
		    «ENDFOR»
		    cycle = '1' else '0';
		  «FOR b:c.blocks»
		  «FOR r:b.registers»
		  res.Block_«b.name».Selected_«r.name» <= '1' when
		    addr( «b.addrIdxHi» downto «b.addrIdxLo» ) = "«r.addrBits»" and
		    cycle = '1' else '0';
		  «ENDFOR»
		  res.Block_«b.name».UnmappedSelection <= '1' when
		    «FOR r:b.registers»
		    res.Block_«b.name».Selected_«r.name» = '0' and
		    «ENDFOR»
		    cycle = '1' else '0';
		  «ENDFOR»
		  «FOR i:c.insts»
		  res.Selected_«i.name» <= '1' when
		    addr( «i.addrIdxHi» downto «i.addrIdxLo» ) = "«i.addrBits»" and
		    cycle = '1' else '0';
		  «ENDFOR»
		end Behavioral;
		«ENDFOR»
		''');
	}
}
